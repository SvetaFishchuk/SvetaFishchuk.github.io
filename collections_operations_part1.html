<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Операции над коллекциями в Python (Таблица 1) </title>
<style>
  .scrollable-table {
        overflow-x: auto; /* Включает горизонтальную прокрутку */
        -webkit-overflow-scrolling: touch;
        width: 100%;
  }
  table {
        width: 200%; /* Увеличиваем таблицу для удобства прокрутки */
        border-collapse: collapse;
  }
  body {
    font-family: Arial, sans-serif;
    background-color: #f4f7fa;
    padding: 20px;
  }
  h1 {
    text-align: center;
    color: #333;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 16px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  th, td {
    padding: 12px 15px;
    border: 1px solid #ddd;
    text-align: left;
    min-width: 200px; /* Увеличиваем минимальную ширину столбцов */
  }
  th {
    background-color: #1142AA;
    color: #ffffff;
    font-weight: bold;
  }
  tr:nth-child(even) {
    background-color: #f2f2f2;
  }
  tr:hover {
    background-color: #e1f5fe;
  }
  td:first-child {
    font-weight: bold;
  }
  code {
    background-color: #f9f9f9;
    padding: 5px;
    border-radius: 3px;
    word-wrap: break-word;
    white-space: pre-wrap;
    display: block;
    margin-bottom: 8px;
    line-height: 1.5;
  }
  /* Styling for the paragraph with the idea */
  #first-content {
      margin-bottom: 30px;
      background-color: #e7f4f9;
      border-left: 5px solid #1f7f82;
      padding: 20px;
      font-size: 1.1em;
      color: #333;
  }
  /* Link styles */
  .link {
      color: #fff;
      text-decoration: none;
      font-size: 1.2em;
      padding: 10px 20px;
      border: 2px solid #fff;
      border-radius: 5px;
      background-color: #015965; /* Blue background color */
      transition: background-color 0.3s, color 0.3s;
      margin-top: 20px;
  }

  .link:hover {
      background-color: #f6ce96;
      color: #333;
  }
</style>
</head>
<body>

<h1>Операции над коллекциями в Python</h1>
<!-- Inserted informative paragraph about collection types -->
<div id="first-content">
Каждая коллекция в Python была разработана с учетом специфических задач, и если операция, такая как деление, не имеет смысла для данного типа коллекции, это скорее всего потому, что она не соответствует исходной концепции этой структуры данных. Важно выбирать подходящий тип коллекции в зависимости от задачи, а не пытаться использовать операцию «просто потому что» — это может привести к лишним трудозатратам и непредсказуемым результатам.
</div>

<table>
    <thead>
      <tr>
        <th>Операция</th>
        <th>Список</th>
        <th>Кортеж</th>
        <th>Множество</th>
        <th>Неизменяемое множество</th>
        <th>Словарь</th>
        <th>Строка</th>
        <th>Массив</th>
      </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>+</code><br>Сложение/Объединение</td>
            <td><code>[1, 2] + [3, 4] -> [1, 2, 3, 4]</code><br><em>Создается новый список с объединенными элементами. Операция не изменяет исходные списки.</em></td>
            <td><code>(1, 2) + (3, 4) -> (1, 2, 3, 4)</code><br><em>Создается новый кортеж с объединенными элементами. Операция не изменяет исходные кортежи.</em></td>
            <td><em>Не поддерживается</em><br>Множества не поддерживают сложение из-за своих математических свойств и отсутствия порядка. Вместо этого используются операции объединения (|) и пересечения (&), которые возвращают новое множество, содержащее уникальные элементы.</td>
            <td><em>Не поддерживается</em></td>
            <td><em>Не поддерживается</em></td>
            <td><code>'ab' + 'cd' -> 'abcd'</code><br><em>Создается новая строка с объединенными символами.</em></td>
            <td>
                <code>array('i', [1, 2]) + array('i', [3, 4])</code><br>
                <em>Сложение в обычных массивах (array) объединяет элементы.</em><br>
                <strong>NumPy</strong>: <code>np.array([1, 2]) + np.array([3, 4]) -> array([4, 6])</code><br>
                <em>NumPy массивы поддерживают покоординатное сложение, создавая новый массив с суммированными элементами на каждой позиции.</em>
            </td>
        </tr>
        <tr>
            <td><strong>Объединение множеств</strong></td>
            <td>❌<br><em>Операция объединения не поддерживается для списков.</em></td>
            <td>❌<br><em>Операция объединения не поддерживается для кортежей.</em></td>
            <td><code>|<br>{1, 2} | {2, 3} # {1, 2, 3}</code><br><em>Операция объединения для множеств, возвращает объединение двух множеств.</em></td>
            <td><code>frozenset([1, 2]) | frozenset([2, 3])</code><br><em>Операция объединения для неизменяемых множеств (frozenset), возвращает объединение двух frozenset.</em></td>
            <td>❌<br><em>Словари не поддерживают операцию объединения с использованием `|`.</em></td>
            <td>❌<br><em>Строки не поддерживают операцию объединения с использованием `|`.</em></td>
            <td>❌<br><em>Массивы не поддерживают операцию объединения с использованием `|`.</em></td>
        </tr>
        <tr>
            <td><code>-</code><br>Вычитание</td>
            <td>❌<em>Не поддерживается</em><br><em>Списки не поддерживают операцию вычитания.</em><br><em>Подобные операции можно реализовать с помощью функций/методов (например, вычитание элементов через list comprehension или фильтрацию).</em></td>
            <td>❌<em>Не поддерживается</em><br><em>Вычитание не поддерживается, потому что концептуально неясно, как должно работать вычитание для кортежей: что будет означать вычитание одного кортежа из другого? Учитывая, что кортежи могут содержать элементы разных типов, не существует очевидного способа вычесть один кортеж из другого, который имел бы смысл во всех случаях.</em><br><em>Подобные операции можно реализовать с помощью функций/методов.</em></td>
            <td>❌<em>Не поддерживается</em><br><em>Множества поддерживают операцию разности: <code>{1, 2, 3} - {2} -> {1, 3}</code>, но это не просто вычитание чисел, а удаление элементов одного множества из другого.</em><br><em>Для более сложных операций можно использовать методы, такие как <code>difference()</code>.</em></td>
            <td>❌<em>Не поддерживается</em><br><em>Неизменяемые множества не поддерживают вычитание по той же причине, что и кортежи: они неизменяемы. Однако операции удаления могут быть выполнены через функции/методы.</em></td>
            <td>❌<em>Не поддерживается</em><br><em>Словари не поддерживают вычитание, так как операция вычитания не имеет смысла для структуры данных словаря. Можно использовать методы для удаления ключей.</em></td>
            <td>❌<em>Не поддерживается</em><br><em>Строки не поддерживают вычитание, так как операция вычитания не имеет смысла для неизменяемых последовательностей символов. Операция вычитания не имеет смысла для текста. В отличие от чисел, строки нельзя "вычесть" друг из друга, потому что это не соответствует стандартным операциям с символами (если только мы не говорим о специализированных методах, как удаление подстрок через методы строк).</em></td>
            <td>
                <strong>NumPy</strong>: <code>np.array([4, 5]) - np.array([1, 2]) -> array([3, 3])</code><br>
                <em>В NumPy массивах операция вычитания выполняется покоординатно, вычитая каждый элемент одного массива из соответствующего элемента другого массива.</em>
            </td>
        </tr>
        <tr>
            <td><strong>Разность множеств</strong></td>
            <td>❌<br><em>Разность множеств не поддерживается для списков, так как списки могут содержать повторяющиеся элементы.</em><br><em>Подобные операции можно реализовать с помощью функций/методов (например, list comprehension для фильтрации элементов).</em></td>
            <td>❌<br><em>Разность множеств не поддерживается для кортежей.</em></td>
            <td><code>-<br>{1, 2} - {2, 3} # {1}</code><br><em>Операция разности множеств возвращает элементы, которые есть в первом множестве, но отсутствуют во втором.</em></td>
            <td><code>frozenset([1, 2]) - frozenset([2, 3])</code><br><em>Для frozenset поддерживается операция разности, аналогичная множествам.</em></td>
            <td>❌<br><em>Для словарей операция разности не поддерживается напрямую, но можно удалить ключи или использовать другие методы.</em></td>
            <td>❌<br><em>Строки не поддерживают операцию разности, так как это не подходящий тип для множеств.</em></td>
            <td>❌<br><em>Массивы не поддерживают операцию разности, так как они не реализуют операции, характерные для множеств.</em></td>
        </tr>
        
        <tr>
            <td><strong>Дублирование <br>(умножение)</strong></td>
            <td><code>*<br>[1, 2] * 3<br># [1, 2, 1, 2, 1, 2]</code><br><em>Операция `*` повторяет элементы списка заданное количество раз. Создается новый список, исходный список остается неизменным.</em></td>
            <td><em>(1, 2) * 3 -> (1, 2, 1, 2, 1, 2)</em><br><em>Операция `*` повторяет элементы кортежа заданное количество раз, создавая новый кортеж.</em></td>
            <td>❌<br><em>Множества не поддерживают умножение, так как они неупорядочены, и операция повторения элементов не имеет смысла для множеств. Множества содержат только уникальные элементы, а повторение элементов нарушает их принцип.</em></td>
            <td>❌<br><em>Неизменяемые множества не поддерживают умножение, так как они неизменяемы.</em></td>
            <td>❌<br><em>Словари не поддерживают операцию умножения, так как операция повторения не имеет смысла для ключей и значений словаря.</em></td>
            <td><code>*<br>"Hi!" * 3<br># 'Hi!Hi!Hi!'</code><br><em>Строки поддерживают операцию умножения с помощью `*`, повторяя строку заданное количество раз.</em></td>
            <td>
                <code>array('i', [1, 2]) * 3<br># array('i', [1, 2, 1, 2, 1, 2])</code><br>
                <em>Умножение в обычных массивах (array) дублирует элементы. Создается новый массив.</em><br>
                <strong>NumPy</strong>: <code>np.array([2, 3]) * 3 -> array([6, 9])</code><br>
                <em>NumPy массивы поддерживают покоординатное умножение, результатом которого является новый массив с произведениями элементов на соответствующих позициях.</em>
            </td>  
        </tr>
        <tr>
          <td><code>/</code><br>Деление</td>
          <td><em>Не поддерживается</em><br><em>Списки не поддерживают стандартное деление, но можно применить операцию к каждому элементу списка с помощью функций или списковых включений. Например, для списка <code>[4, 6]</code> операция деления может быть выполнена так: <code>[x / 2 for x in [4, 6]] -> [2.0, 3.0]</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Кортежи не поддерживают стандартное деление, так как они неизменяемы. Однако, как и со списками, можно применить операцию деления к каждому элементу кортежа с помощью выражений, например: <code>(x / 2 for x in (4, 6)) -> (2.0, 3.0)</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Множества не поддерживают деление, так как операция не имеет смысла для множеств, так как их элементы не имеют порядка. Однако можно использовать генераторы для применения деления к каждому элементу множества, например: <code>{x / 2 for x in {4, 6}} -> {2.0}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Неизменяемые множества не поддерживают деление. Например, для frozenset: <code>{x / 2 for x in frozenset([4, 6])} -> {2.0}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Словари не поддерживают деление, так как операция не имеет смысла для их структуры данных. Однако, можно применить операцию деления к значениям словаря, например: <code>{k: v / 2 for k, v in {'a': 4, 'b': 6}.items()} -> {'a': 2.0, 'b': 3.0}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Строки не поддерживают операцию деления, так как деление не имеет смысла для строк.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([4, 6]) / np.array([2, 3]) -> array([2.0, 2.0])</code><br>
              <em>NumPy массивы поддерживают покоординатное деление.</em>
          </td>
      </tr>
      <tr>
          <td><code>//</code><br>Целочисленное деление</td>
          <td><em>Не поддерживается</em><br><em>Целочисленное деление не поддерживается для списков, но можно применить его к каждому элементу списка с помощью функций или списковых включений. Например: <code>[x // 2 for x in [5, 9]] -> [2, 4]</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Целочисленное деление не поддерживается для кортежей, так как они неизменяемы. Однако можно применить целочисленное деление к каждому элементу кортежа с помощью выражений, например: <code>(x // 2 for x in (5, 9)) -> (2, 4)</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Множества не поддерживают целочисленное деление, так как операция не имеет смысла для множеств. Можно использовать генераторы для применения целочисленного деления к каждому элементу множества, например: <code>{x // 2 for x in {5, 9}} -> {2}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Неизменяемые множества не поддерживают целочисленное деление. Например, для frozenset: <code>{x // 2 for x in frozenset([5, 9])} -> {2}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Словари не поддерживают операцию целочисленного деления, так как она не имеет смысла для их структуры данных. Однако, можно применить операцию к значениям словаря, например: <code>{k: v // 2 for k, v in {'a': 5, 'b': 9}.items()} -> {'a': 2, 'b': 4}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Строки не поддерживают целочисленное деление.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([5, 9]) // np.array([2, 3]) -> array([2, 3])</code><br>
              <em>NumPy массивы поддерживают покоординатное целочисленное деление.</em>
          </td>
      </tr>
      <tr>
          <td><code>%</code><br>Остаток от деления</td>
          <td><em>Не поддерживается</em><br><em>Остаток от деления не поддерживается для списков, но можно применить его к каждому элементу списка с помощью функций или списковых включений. Например: <code>[x % 3 for x in [5, 9]] -> [2, 0]</code>. Это полезно, если нужно вычислить остаток от деления для каждого элемента списка, не изменяя сам список.</em></td>
          <td><em>Не поддерживается</em><br><em>Остаток от деления не поддерживается для кортежей, так как они неизменяемы. Однако можно применить остаток от деления к каждому элементу кортежа с помощью генераторов или выражений, например: <code>(x % 3 for x in (5, 9)) -> (2, 0)</code>. Это создает новый кортеж с результатами операции.</em></td>
          <td><em>Не поддерживается</em><br><em>Множества не поддерживают остаток от деления, так как операция не имеет смысла для множества, поскольку множества не упорядочены. Однако можно использовать генераторы для вычисления остатка от деления для каждого элемента множества, например: <code>{x % 3 for x in {5, 9}} -> {2}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Неизменяемые множества не поддерживают остаток от деления. Однако можно создать новое множество с результатами операции, например: <code>{x % 3 for x in frozenset([5, 9])} -> {2}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Словари не поддерживают операцию остатка от деления, так как она не имеет смысла для их структуры данных. Однако можно применить операцию к значениям словаря с помощью выражений, например: <code>{k: v % 3 for k, v in {'a': 5, 'b': 9}.items()} -> {'a': 2, 'b': 0}</code>.</em></td>
          <td><em>Не поддерживается</em><br><em>Строки не поддерживают операцию остатка от деления, так как операция не имеет смысла для строковых данных. Однако можно использовать функции для работы с символами строк, например: <code>"abc".join([str(ord(x) % 3) for x in "abc"])</code> — в данном примере операция выполняется над символами строки.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([5, 9]) % np.array([2, 4]) -> array([1, 1])</code><br>
              <em>NumPy массивы поддерживают покоординатный остаток от деления, что позволяет эффективно работать с массивами чисел, вычисляя остаток для каждого элемента массива.</em>
          </td>
      </tr>      
        <tr>
            <td><code>**</code><br>Возведение в степень</td>
            <td><em>Не поддерживается</em><br><em>Возведение в степень не поддерживается для списков, но можно применить его к каждому элементу списка с помощью функций или списковых включений. Например: <code>[x ** 2 for x in [2, 3]] -> [4, 9]</code>. Это полезно, если нужно возвести в степень элементы списка, не изменяя сам список.</em></td>
            <td><em>Не поддерживается</em><br><em>Возведение в степень не поддерживается для кортежей, так как они неизменяемы. Однако можно применить возведение в степень к каждому элементу кортежа с помощью выражений, например: <code>(x ** 2 for x in (2, 3)) -> (4, 9)</code>. Использование генераторов позволяет создавать новый кортеж с возведёнными в степень значениями.</em></td>
            <td><em>Не поддерживается</em><br><em>Множества не поддерживают возведение в степень, так как операция не имеет смысла для множества, поскольку множества не сохраняют порядок элементов. Однако можно использовать функции или выражения для возведения в степень каждого элемента множества, например: <code>{x ** 2 for x in {2, 3}} -> {4, 9}</code>.</em></td>
            <td><em>Не поддерживается</em><br><em>Неизменяемые множества не поддерживают возведение в степень. Однако, как и для обычных множеств, можно создать новое множество с элементами, возведенными в степень с помощью выражений: <code>{x ** 2 for x in frozenset([2, 3])} -> {4, 9}</code>.</em></td>
            <td><em>Не поддерживается</em><br><em>Словари не поддерживают операцию возведения в степень, так как она не имеет смысла для ключей и значений. Однако, можно применить операцию к значениям словаря, используя генераторы или функции: <code>{k: v ** 2 for k, v in {'a': 2, 'b': 3}.items()} -> {'a': 4, 'b': 9}</code>.</em></td>
            <td><em>Не поддерживается</em><br><em>Строки не поддерживают операцию возведения в степень, так как она не имеет смысла для строковых данных. Однако можно использовать генератор или функцию для выполнения операций с каждым символом строки: <code>"abc".join(['x' ** 2 for x in 'abc'])</code> — данный пример покажет принцип работы с символами строк, но возведение в степень непосредственно к строкам неприменимо.</em></td>
            <td>
                <strong>NumPy</strong>: <code>np.array([2, 3]) ** 2 -> array([4, 9])</code><br>
                <em>NumPy массивы поддерживают покоординатное возведение в степень, что позволяет работать с массивами чисел эффективно, возводя каждый элемент в степень независимо от других.</em>
            </td>
        </tr>        
      <tr>
        <td><strong>Получение ключей и значений</strong></td>
        <td>❌</td>
        <td>❌</td>
        <td>❌</td>
        <td>❌</td>
        <td><code>d = {'a': 1};<br>d.keys() # ['a']<br>d.values() # [1]</code><br><em>Методы `keys()` и `values()` доступны только для словарей (`dict`). Они позволяют получить ключи и значения. Множества, кортежи и другие типы данных не поддерживают этот функционал, так как они не имеют структуры «ключ-значение».</em></td>
        <td>❌</td>
      </tr>
         
        <tr>
            <td><strong>Проверка на равенство</strong></td>
            <td><code>==<br>[1, 2] == [1, 2]<br># True</code><br><em>Оператор `==` проверяет, равны ли значения объектов. В этом случае два списка содержат одинаковые элементы в одинаковом порядке, что делает их равными.</em></td>
            <td><code>==<br>(1, 2) == (1, 2)<br># True</code><br><em>Сравниваются кортежи, и `==` проверяет, равны ли их элементы. Кортежи с одинаковыми элементами считаются равными, несмотря на то, что они могут быть разными объектами в памяти.</em></td>
            <td><code>==<br>{1, 2} == {2, 1}<br># True</code><br><em>Множества не зависят от порядка элементов, поэтому два множества с одинаковыми элементами равны, даже если порядок отличается.</em></td>
            <td><code>==<br>frozenset([1, 2]) == frozenset([2, 1])<br># True</code><br><em>Для `frozenset`, как и для множеств, порядок не имеет значения, и два неизменяемых множества с одинаковыми элементами считаются равными.</em></td>
            <td><code>==<br>{'a': 1} == {'a': 1}<br># True</code><br><em>Словари сравниваются по ключам и значениям. Если у двух словарей одинаковые ключи и значения, они считаются равными, независимо от их порядка.</em></td>
            <td><code>==<br>"abc" == "abc"<br># True</code><br><em>Строки сравниваются по содержимому. Две строки с одинаковыми символами считаются равными, независимо от их расположения в памяти.</em></td>
            <td><code>==<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 == arr2<br># True</code><br><em>Для массивов (модуль `array`) проверяется равенство значений, и массивы с одинаковыми элементами считаются равными.</em></td>
          </tr>
          <tr>
            <td><strong>Проверка на неравенство</strong></td>
            <td><code>!=<br>[1, 2] != [2, 1]<br># True</code><br><em>Оператор `!=` проверяет, не равны ли два объекта. В этом примере, несмотря на то что оба списка содержат одинаковые элементы, их порядок различен, поэтому списки не равны.</em></td>
            <td><code>!=<br>(1, 2) != (2, 1)<br># True</code><br><em>Кортежи с одинаковыми элементами, но в разном порядке считаются неравными, так как `!=` проверяет не только значения, но и порядок элементов.</em></td>
            <td><code>!=<br>{1, 2} != {3, 4}<br># True</code><br><em>Множества с различными элементами всегда будут неравными, вне зависимости от порядка элементов.</em></td>
            <td><code>!=<br>frozenset([1, 2]) != frozenset([3, 4])<br># True</code><br><em>Аналогично множествам, `frozenset` с различными элементами считаются неравными.</em></td>
            <td><code>!=<br>{'a': 1} != {'b': 2}<br># True</code><br><em>Словари с разными ключами или значениями считаются неравными, и оператор `!=` вернет `True` в этом случае.</em></td>
            <td><code>!=<br>"abc" != "def"<br># True</code><br><em>Два строки с различным содержимым считаются неравными.</em></td>
            <td><code>!=<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [2, 1]);<br>arr1 != arr2<br># True</code><br><em>Массивы с разными элементами или разным порядком элементов считаются неравными.</em></td>
          </tr>
          <tr>
            <td><strong>Проверка на сравнение</strong></td>
            <td><code>&gt;<br>[3, 4] > [2, 1]<br># True</code><br><em>Оператор <code>&gt;</code> проверяет, больше ли первый объект (список) по сравнению с вторым. Списки сравниваются поэлементно, пока не будет найдено различие.</em></td>
            <td><code>&gt;<br>(3, 4) > (2, 1)<br># True</code><br><em>Для кортежей <code>&gt;</code> сравнивает элементы по порядку, начиная с первого, и возвращает <code>True</code>, если первый элемент больше. Если элементы равны, происходит сравнение следующего элемента.</em></td>
            <td><code>&gt;<br>{3, 4} > {1, 2}<br># True</code><br><em>Множества не имеют порядка, но операция <code>&gt;</code> может быть использована для сравнения множеств по их размеру или значениям (сравнение по элементам).</em></td>
            <td><code>&gt;<br>frozenset([3, 4]) > frozenset([1, 2])<br># True</code><br><em>Как и множества, <code>frozenset</code> можно сравнивать по элементам, но также можно использовать сравнение по количеству элементов.</em></td>
            <td><code>&gt;<br>{'a': 3} > {'a': 2}<br># True</code><br><em>Для словарей <code>&gt;</code> сравнивает значения по ключам. Если значения первого словаря больше, чем у второго, результат будет <code>True</code>.</em></td>
            <td><code>&gt;<br>"abc" > "abb"<br># True</code><br><em>Строки сравниваются лексикографически. Оператор <code>&gt;</code> возвращает <code>True</code>, если строка идет после другой в алфавите.</em></td>
            <td><code>&gt;<br>import array;<br>arr1 = array.array('i', [3, 4]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 > arr2<br># True</code><br><em>Для массивов сравнение <code>&gt;</code> работает поэлементно, как и для других коллекций. Если первый элемент массива больше второго, то операция возвращает <code>True</code>.</em></td>
        </tr>        
        <tr>
            <td><code>&lt;</code><br>Меньше</td>
            <td><code>&lt;<br>[1, 2] < [3, 4]<br># True</code><br><em>Оператор <code>&lt;</code> проверяет, меньше ли первый объект по сравнению с вторым. Сравнение осуществляется поэлементно, возвращая <code>True</code>, если все элементы первого списка меньше.</em></td>
            <td><code>&lt;<br>(1, 2) < (3, 4)<br># True</code><br><em>Для кортежей сравнение также выполняется поэлементно, и оператор <code>&lt;</code> возвращает <code>True</code>, если первый элемент меньше.</em></td>
            <td><code>&lt;<br>{1, 2} < {3, 4}<br># True</code><br><em>Для множеств операция <code>&lt;</code> проверяет, является ли одно множество подмножеством другого. Если это так, результат будет <code>True</code>.</em></td>
            <td><code>&lt;<br>frozenset([1, 2]) < frozenset([3, 4])<br># True</code><br><em>Для <code>frozenset</code> проверяется, является ли первое множество подмножеством второго. Если да, то возвращается <code>True</code>.</em></td>
            <td><code>&lt;<br>{'a': 1} < {'a': 2}<br># True</code><br><em>Словари сравниваются по значениям. Если значения одного словаря меньше, чем у другого, возвращается <code>True</code>.</em></td>
            <td><code>&lt;<br>"abc" < "abd"<br># True</code><br><em>Для строк операторы <code>&lt;</code> выполняют лексикографическое сравнение и возвращают <code>True</code>, если строка идет раньше другой.</em></td>
            <td><code>&lt;<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [3, 4]);<br>arr1 < arr2<br># True</code><br><em>Для массивов <code>&lt;</code> сравнивает элементы поочередно, как и для других коллекций, и если первый массив "меньше", то возвращает <code>True</code>.</em></td>
        </tr>
        
        <tr>
            <td><code>&gt;=</code><br>Больше или равно</td>
            <td><code>&gt;=<br>[3, 4] >= [3, 4]<br># True</code><br><em>Оператор <code>&gt;=</code> проверяет, больше или равно ли значение первого объекта второму. Списки сравниваются поэлементно, и если первый список не меньше второго, результат будет <code>True</code>.</em></td>
            <td><code>&gt;=<br>(3, 4) >= (3, 4)<br># True</code><br><em>Для кортежей проверяется, является ли первый кортеж больше или равен второму по элементам. Если это так, возвращается <code>True</code>.</em></td>
            <td><code>&gt;=<br>{3, 4} >= {1, 2}<br># True</code><br><em>Для множеств оператор <code>&gt;=</code> проверяет, является ли первое множество надмножеством второго, то есть все элементы первого множества присутствуют во втором.</em></td>
            <td><code>&gt;=<br>frozenset([3, 4]) >= frozenset([1, 2])<br># True</code><br><em>Для <code>frozenset</code> оператор <code>&gt;=</code> проверяет, является ли первое множество подмножеством или равным второму.</em></td>
            <td><code>&gt;=<br>{'a': 3} >= {'a': 2}<br># True</code><br><em>Словари сравниваются по значениям, и оператор <code>&gt;=</code> вернет <code>True</code>, если значение в первом словаре больше или равно значению во втором.</em></td>
            <td><code>&gt;=<br>"abc" >= "abc"<br># True</code><br><em>Строки сравниваются лексикографически. Оператор <code>&gt;=</code> возвращает <code>True</code>, если первая строка равна или идет после второй в алфавите.</em></td>
            <td><code>&gt;=<br>import array;<br>arr1 = array.array('i', [3, 4]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 >= arr2<br># True</code><br><em>Для массивов сравнивается значение каждого элемента. Оператор <code>&gt;=</code> вернет <code>True</code>, если массив не меньше другого.</em></td>
        </tr>
        
        <tr>
            <td><code>&lt;=</code><br>Меньше или равно</td>
            <td><code>&lt;=<br>[1, 2] <= [3, 4]<br># True</code><br><em>Оператор <code>&lt;=</code> проверяет, меньше ли первый объект второго или равен ему. В случае списков элементы сравниваются по порядку, и если первый список меньше или равен по значению второму, результат будет <code>True</code>.</em></td>
            <td><code>&lt;=<br>(1, 2) <= (3, 4)<br># True</code><br><em>Для кортежей оператор <code>&lt;=</code> выполняет поэлементное сравнение. Результат будет <code>True</code>, если все элементы первого кортежа меньше или равны соответствующим элементам второго кортежа.</em></td>
            <td><code>&lt;=<br>{1, 2} <= {3, 4}<br># True</code><br><em>Множества не имеют порядка, но оператор <code>&lt;=</code> проверяет, является ли первое множество подмножеством второго. Если первое множество содержит все элементы второго или меньше, результат будет <code>True</code>.</em></td>
            <td><code>&lt;=<br>frozenset([1, 2]) <= frozenset([3, 4])<br># True</code><br><em>Для <code>frozenset</code> оператор <code>&lt;=</code> проверяет, является ли первое множество подмножеством второго. Это верно даже для неизменяемых множеств.</em></td>
            <td><code>&lt;=<br>{'a': 1} <= {'a': 2}<br># True</code><br><em>Для словарей оператор <code>&lt;=</code> сравнивает значения по ключам. Если значения первого словаря меньше или равны значениям второго словаря, результат будет <code>True</code>.</em></td>
            <td><code>&lt;=<br>"abc" <= "abc"<br># True</code><br><em>Строки сравниваются лексикографически. Оператор <code>&lt;=</code> возвращает <code>True</code>, если первая строка лексикографически меньше или равна второй.</em></td>
            <td><code>&lt;=<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [3, 4]);<br>arr1 <= arr2<br># True</code><br><em>Для массивов оператор <code>&lt=</code> сравнивает элементы поочередно, и если все элементы первого массива меньше или равны соответствующим элементам второго массива, возвращается <code>True</code>.</em></td>
        </tr>
                
        <tr>
            <td><strong>Проверка идентичности</strong></td>
            <td><code>is<br>lst1 = [1, 2];<br>lst2 = lst1;<br>lst1 is lst2<br># True</code><br><em>Сравнивает, ссылаются ли переменные на один и тот же объект в памяти. Важно для проверок идентичности объектов, особенно когда требуется понять, ссылаются ли переменные на один и тот же изменяемый объект.</em></td>
            <td><code>is<br>tup1 = (1, 2);<br>tup2 = tup1;<br>tup1 is tup2<br># True</code><br><em>Так как кортежи — неизменяемые объекты, Python может использовать кеширование, чтобы ссылки на одинаковые кортежи указывали на один и тот же объект в памяти.</em></td>
            <td><code>is<br>s1 = {1, 2};<br>s2 = s1;<br>s1 is s2<br># True</code><br><em>Множества — изменяемые объекты, поэтому `is` проверяет, ссылаются ли две переменные на один и тот же объект в памяти.</em></td>
            <td><code>is<br>fs1 = frozenset([1, 2]);<br>fs2 = fs1;<br>fs1 is fs2<br># True</code><br><em>Проверяет идентичность неизменяемых объектов, таких как frozenset, которые могут быть кешированы.</em></td>
            <td><code>is<br>d1 = {'a': 1};<br>d2 = d1;<br>d1 is d2<br># True</code><br><em>Словари — изменяемые объекты, и использование `is` позволяет убедиться, что обе переменные ссылаются на один и тот же словарь.</em></td>
            <td><code>is<br>s1 = "abc";<br>s2 = s1;<br>s1 is s2<br># True</code><br><em>Для строк, как для неизменяемых объектов, Python может использовать кеширование, что означает, что две переменные могут ссылаться на один и тот же объект, если строки одинаковы.</em></td>
            <td><code>is<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = arr1;<br>arr1 is arr2<br># True</code><br><em>Для массивов `array` операция `is` проверяет, ссылаются ли переменные на один и тот же объект в памяти, как и для других изменяемых объектов.</em></td>
        </tr>
        <tr>
            <td><strong>Проверка идентичности (is not)</strong></td>
            <td><code>is not<br>lst1 = [1, 2];<br>lst2 = [1, 2];<br>lst1 is not lst2<br># True</code><br><em>Оператор `is not` проверяет, что две переменные не ссылаются на один и тот же объект в памяти. В примере с двумя списками <code>lst1</code> и <code>lst2</code> они имеют одинаковые значения, но Python создаст два разных объекта в памяти, так что результат будет True.</em></td>
            <td><code>is not<br>tup1 = (1, 2);<br>tup2 = (1, 2);<br>tup1 is not tup2<br># True</code><br><em>Кортежи, несмотря на свою неизменяемость, могут быть разными объектами в памяти, даже если их содержимое одинаково. Поэтому оператор `is not` может вернуть True, если кортежи расположены в разных местах памяти.</em></td>
            <td><code>is not<br>s1 = {1, 2};<br>s2 = {1, 2};<br>s1 is not s2<br># True</code><br><em>Для множеств, как для изменяемых объектов, `is not` проверяет, ссылаются ли две переменные на разные объекты в памяти. Даже если множества идентичны по содержимому, они могут находиться в разных областях памяти.</em></td>
            <td><code>is not<br>fs1 = frozenset([1, 2]);<br>fs2 = frozenset([1, 2]);<br>fs1 is not fs2<br># True</code><br><em>Для неизменяемых объектов, таких как frozenset, можно получить результат True, если они были созданы в разных местах памяти, даже если содержат одинаковые элементы.</em></td>
            <td><code>is not<br>d1 = {'a': 1};<br>d2 = {'a': 1};<br>d1 is not d2<br># True</code><br><em>Словари — изменяемые объекты, и даже если их содержимое одинаково, они могут находиться в разных областях памяти. Поэтому использование `is not` подтвердит, что это разные объекты.</em></td>
            <td><code>is not<br>s1 = "abc";<br>s2 = "abc";<br>s1 is not s2<br># False</code><br><em>Для строк, как для неизменяемых объектов, Python может использовать кеширование, что означает, что переменные с одинаковыми строками могут ссылаться на один и тот же объект. В случае строк результат оператора `is not` часто будет False.</em></td>
            <td><code>is not<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 is not arr2<br># True</code><br><em>Для массивов `array`, как и для других изменяемых объектов, `is not` проверяет, ссылаются ли переменные на разные объекты в памяти, даже если их содержимое одинаково.</em></td>
        </tr>
        <tr>
            <td><strong>Операции членства</strong></td>
            <td><code>in<br>lst = [1, 2, 3];<br>2 in lst<br># True</code><br><em>Оператор <code>in</code> проверяет, содержится ли элемент в списке. В данном примере проверяется, присутствует ли число 2 в списке.</em></td>
            <td><code>in<br>tup = (1, 2, 3);<br>2 in tup<br># True</code><br><em>Оператор <code>in</code> проверяет, содержится ли элемент в кортеже. Как и для списков, проверка элементом осуществляется с учетом его существования в кортеже.</em></td>
            <td><code>in<br>s = {1, 2, 3};<br>2 in s<br># True</code><br><em>Оператор <code>in</code> также работает с множествами, проверяя, содержится ли элемент в множестве.</em></td>
            <td><code>in<br>fs = frozenset([1, 2, 3]);<br>2 in fs<br># True</code><br><em>Оператор <code>in</code> работает с неизменяемыми множествами <code>frozenset</code>, проверяя наличие элемента в множестве.</em></td>
            <td><code>in<br>d = {'a': 1, 'b': 2};<br>'a' in d<br># True</code><br><em>Для словарей <code>in</code> проверяет наличие ключа в словаре, а не значение. В данном примере проверяется наличие ключа <code>'a'</code>.</em></td>
            <td><code>in<br>s = "abc";<br>'b' in s<br># True</code><br><em>Для строк <code>in</code> проверяет наличие подстроки в строке. В данном примере проверяется, есть ли символ <code>'b'</code> в строке <code>'abc'</code>.</em></td>
            <td><code>in<br>arr = array.array('i', [1, 2, 3]);<br>2 in arr<br># True</code><br><em>Для массивов <code>array</code> оператор <code>in</code> проверяет, содержится ли элемент в массиве.</em></td>
        </tr>
        <tr>
            <td><code>not in</code><br>Проверка на отсутствие элемента</td>
            <td><code>not in<br>lst = [1, 2, 3];<br>4 not in lst<br># True</code><br><em>Оператор <code>not in</code> проверяет, отсутствует ли элемент в списке. В данном примере проверяется, отсутствует ли число 4 в списке.</em></td>
            <td><code>not in<br>tup = (1, 2, 3);<br>4 not in tup<br># True</code><br><em>Оператор <code>not in</code> проверяет, отсутствует ли элемент в кортеже.</em></td>
            <td><code>not in<br>s = {1, 2, 3};<br>4 not in s<br># True</code><br><em>Для множеств оператор <code>not in</code> проверяет, отсутствует ли элемент в множестве.</em></td>
            <td><code>not in<br>fs = frozenset([1, 2, 3]);<br>4 not in fs<br># True</code><br><em>Для <code>frozenset</code> оператор <code>not in</code> проверяет, отсутствует ли элемент в неизменяемом множестве.</em></td>
            <td><code>not in<br>d = {'a': 1, 'b': 2};<br>'c' not in d<br># True</code><br><em>Для словарей <code>not in</code> проверяет отсутствие ключа в словаре.</em></td>
            <td><code>not in<br>s = "abc";<br>'d' not in s<br># True</code><br><em>Для строк <code>not in</code> проверяет, отсутствует ли подстрока в строке.</em></td>
            <td><code>not in<br>arr = array.array('i', [1, 2, 3]);<br>4 not in arr<br># True</code><br><em>Для массивов <code>array</code> оператор <code>not in</code> проверяет, отсутствует ли элемент в массиве.</em></td>
        </tr>
        <tr>
            <td><strong>Итерирование</strong></td>
            <td><code>for item in [1, 2, 3]:<br> print(item)</code><br><em>Итерация по списку, доступ к каждому элементу по порядку.</em></td>
            <td><code>for item in (1, 2, 3):<br> print(item)</code><br><em>Итерация по кортежу, доступ к каждому элементу по порядку.</em></td>
            <td><code>for item in {1, 2, 3}:<br> print(item)</code><br><em>Итерация по множеству, элементы выводятся в неопределенном порядке.</em></td>
            <td><code>for item in frozenset([1, 2, 3]):<br> print(item)</code><br><em>Итерация по неизменяемому множеству (frozenset), элементы выводятся в неопределенном порядке.</em></td>
            <td><code>for k, v in {'a': 1}.items():<br> print(k, v)</code><br><em>Итерация по словарю, доступ к ключам и значениям.</em></td>
            <td><code>for char in 'Hello':<br> print(char)</code><br><em>Итерация по строке, доступ к каждому символу по порядку.</em></td>
            <td><code>for item in array('i', [1, 2, 3]):<br> print(item)</code><br><em>Итерация по массиву, доступ к каждому элементу по порядку.</em></td>
          </tr>
  </tbody>
</table>

<a href="index.html" class="link">Go Back to Home</a>

</body>
</html>
