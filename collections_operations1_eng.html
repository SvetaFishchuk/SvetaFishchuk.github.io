<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Operations on Collections in Python (Table 1) </title>
<style>
  .scrollable-table {
        overflow-x: auto; /* Включаем горизонтальную прокрутку */
        -webkit-overflow-scrolling: touch;
        width: 100%;
  }
  table {
        width: 200%; /* Увеличиваем таблицу для удобства прокрутки */
        border-collapse: collapse;
  }
  body {
    font-family: Arial, sans-serif;
    background-color: #f4f7fa;
    padding: 20px;
  }
  h1 {
    text-align: center;
    color: #333;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 16px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  th, td {
    padding: 12px 15px;
    border: 1px solid #ddd;
    text-align: left;
    min-width: 200px;
  }
  th {
    background-color: #1142AA;
    color: #ffffff;
    font-weight: bold;
  }
  tr:nth-child(even) {
    background-color: #f2f2f2;
  }
  tr:hover {
    background-color: #e1f5fe;
  }
  td:first-child {
    font-weight: bold;
  }
  code {
    background-color: #f9f9f9;
    padding: 5px;
    border-radius: 3px;
    word-wrap: break-word;
    white-space: pre-wrap;
    display: block;
    margin-bottom: 8px;
    line-height: 1.5;
  }
  /* Styling for the paragraph with the idea */
  #first-content {
      margin-bottom: 30px;
      background-color: #e7f4f9;
      border-left: 5px solid #1f7f82;
      padding: 20px;
      font-size: 1.1em;
      color: #333;
  }
  /* Link styles */
  .link {
      color: #fff;
      text-decoration: none;
      font-size: 1.2em;
      padding: 10px 20px;
      border: 2px solid #fff;
      border-radius: 5px;
      background-color: #015965; /* Blue background color */
      transition: background-color 0.3s, color 0.3s;
      margin-top: 20px;
  }

  .link:hover {
      background-color: #f6ce96;
      color: #333;
  }
</style>
</head>
<body>

<h1>Operations on Collections in Python (Table 1)</h1>
<!-- Inserted informative paragraph about collection types -->
<div id="first-content">
  <p>Each collection type in Python is designed with specific use cases in mind. If an operation, like division, doesn't make sense for a given collection, it's likely because it doesn't align with the original purpose of that data structure. It's important to choose the right collection type for the task at hand, rather than forcing an operation that could lead to unnecessary complexity and unpredictable results.</p>
</div>

<table>
    <thead>
      <tr>
        <th>Operation</th>
        <th>List</th>
        <th>Tuple</th>
        <th>Set</th>
        <th>Immutable Set</th>
        <th>Dictionary</th>
        <th>String</th>
        <th>Array</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>+</code><br>Addition/Union</td>
          <td><code>[1, 2] + [3, 4] -> [1, 2, 3, 4]</code><br><em>A new list is created with the combined elements. The operation does not modify the original lists.</em></td>
          <td><code>(1, 2) + (3, 4) -> (1, 2, 3, 4)</code><br><em>A new tuple is created with the combined elements. The operation does not modify the original tuples.</em></td>
          <td><em>Not supported</em><br>Sets do not support addition due to their mathematical properties and lack of order. Instead, union (|) and intersection (&) operations are used, which return a new set containing unique elements.</td>
          <td><em>Not supported</em></td>
          <td><em>Not supported</em></td>
          <td><code>'ab' + 'cd' -> 'abcd'</code><br><em>A new string is created with the combined characters.</em></td>
          <td>
              <code>array('i', [1, 2]) + array('i', [3, 4])</code><br>
              <em>In standard arrays (array), addition combines elements.</em><br>
              <strong>NumPy</strong>: <code>np.array([1, 2]) + np.array([3, 4]) -> array([4, 6])</code><br>
              <em>NumPy arrays support element-wise addition, creating a new array with summed elements at each position.</em>
          </td>
        </tr>
        <tr>
            <td><strong>Set Union</strong></td>
            <td>❌<br><em>The union operation is not supported for lists.</em></td>
            <td>❌<br><em>The union operation is not supported for tuples.</em></td>
            <td><code>|<br>{1, 2} | {2, 3} # {1, 2, 3}</code><br><em>Union operation for sets, returns the union of two sets.</em></td>
            <td><code>frozenset([1, 2]) | frozenset([2, 3])</code><br><em>Union operation for immutable sets (frozenset), returns the union of two frozensets.</em></td>
            <td>❌<br><em> Dictionaries do not support the union operation using `|`.</em></td>
            <td>❌<br><em>Strings do not support the union operation using `|`.</em></td>
            <td>❌<br><em>Arrays do not support the union operation using `|`.</em></td>
        </tr>
        <tr>
            <td><code>-</code><br>Subtraction</td>
            <td>❌<em>Not Supported</em><br><em>Lists do not support the subtraction operation.</em><br><em>Similar behavior can be achieved using functions/methods (e.g., list comprehension or filtering to remove elements).</em></td>
            <td>❌<em>Not Supported</em><br><em>Subtraction is unsupported for tuples because conceptually, it is unclear how subtraction would work for them: what would it mean to subtract one tuple from another? Since tuples can contain elements of different types, there is no clear, universal way to perform tuple subtraction that would make sense in all cases.</em><br><em>Similar operations can be implemented using functions/methods.</em></td>
            <td>❌<em>Not Supported</em><br><em>Sets do support the difference operation: <code>{1, 2, 3} - {2} -> {1, 3}</code>, but this is not simple numeric subtraction; it removes elements of one set from another.</em><br><em>For more complex operations, methods like <code>difference()</code> can be used.</em></td>
            <td>❌<em>Not Supported</em><br><em>Immutable sets do not support subtraction for the same reason as tuples: they are immutable. However, removal operations can be performed through functions/methods.</em></td>
            <td>❌<em>Not Supported</em><br><em>Dictionaries do not support subtraction, as the operation does not make sense for dictionary data structure. Keys can be removed using methods.</em></td>
            <td>❌<em>Not Supported</em><br><em>Strings do not support subtraction, as this operation does not make sense for immutable sequences of characters. Unlike numbers, strings cannot be "subtracted" from one another, as it does not align with standard character manipulation operations (unless through specialized methods like substring removal).</em></td>
            <td>
                <strong>NumPy</strong>: <code>np.array([4, 5]) - np.array([1, 2]) -> array([3, 3])</code><br>
                <em>In NumPy arrays, subtraction is performed element-wise, subtracting each element of one array from the corresponding element of another.</em>
            </td>
        </tr>
        <tr>
          <td><strong>Set Difference</strong></td>
          <td>❌<br><em>Set difference is not supported for lists, as lists can contain duplicate elements.</em><br><em>Similar operations can be achieved using functions/methods (e.g., list comprehension to filter elements).</em></td>
          <td>❌<br><em>Set difference is not supported for tuples.</em></td>
          <td><code>-<br>{1, 2} - {2, 3} # {1}</code><br><em>The set difference operation returns elements present in the first set but not in the second.</em></td>
          <td><code>frozenset([1, 2]) - frozenset([2, 3])</code><br><em>The difference operation is supported for frozensets, similar to sets.</em></td>
          <td>❌<br><em>Set difference is not directly supported for dictionaries, but keys can be removed or other methods can be applied.</em></td>
          <td>❌<br><em>Strings do not support set difference, as they are not a suitable type for set-like operations.</em></td>
          <td>❌<br><em>Arrays do not support set difference, as they do not implement set-based operations.</em></td>
        </tr>
        <tr>
          <td><strong>Duplication <br>(Multiplication)</strong></td>
          <td><code>*<br>[1, 2] * 3<br># [1, 2, 1, 2, 1, 2]</code><br><em>The `*` operation repeats list elements a specified number of times. A new list is created; the original list remains unchanged.</em></td>
          <td><code>(1, 2) * 3 -> (1, 2, 1, 2, 1, 2)</code><br><em>The `*` operation repeats tuple elements the specified number of times, creating a new tuple.</em></td>
          <td>❌<br><em>Sets do not support multiplication because they are unordered and the concept of repeating elements is not meaningful for sets, which only contain unique elements. Repetition would violate this principle.</em></td>
          <td>❌<br><em>Immutable sets do not support multiplication as they are immutable.</em></td>
          <td>❌<br><em>Dictionaries do not support the multiplication operation, as repetition is not meaningful for keys and values in a dictionary.</em></td>
          <td><code>*<br>"Hi!" * 3<br># 'Hi!Hi!Hi!'</code><br><em>Strings support the `*` operation, repeating the string the specified number of times.</em></td>
          <td>
              <code>array('i', [1, 2]) * 3<br># array('i', [1, 2, 1, 2, 1, 2])</code><br>
              <em>Multiplication in regular arrays (array) duplicates elements, creating a new array.</em><br>
              <strong>NumPy</strong>: <code>np.array([2, 3]) * 3 -> array([6, 9])</code><br>
              <em>NumPy arrays support element-wise multiplication, resulting in a new array with each element multiplied by the given factor.</em>
          </td>
        </tr>
        <tr>
          <td><code>/</code><br>Division</td>
          <td><em>Not supported</em><br><em>Lists do not support standard division, but you can apply the operation to each element in a list using functions or list comprehensions. For example, for a list <code>[4, 6]</code>, division can be performed like this: <code>[x / 2 for x in [4, 6]] -> [2.0, 3.0]</code>.</em></td>
          <td><em>Not supported</em><br><em>Tuples do not support standard division, as they are immutable. However, as with lists, division can be applied to each tuple element using expressions, e.g., <code>(x / 2 for x in (4, 6)) -> (2.0, 3.0)</code>.</em></td>
          <td><em>Not supported</em><br><em>Sets do not support division, as this operation has no logical meaning for sets.</em></td>
          <td><em>Not supported</em><br><em>Immutable sets do not support division.</em></td>
          <td><em>Not supported</em><br><em>Dictionaries do not support division, as it does not fit their data structure.</em></td>
          <td><em>Not supported</em><br><em>Strings do not support division, as the operation has no logical meaning for strings.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([4, 6]) / np.array([2, 3]) -> array([2, 2])</code><br>
              <em>NumPy arrays support element-wise division.</em>
          </td>
        </tr>
        <tr>
          <td><code>//</code><br>Integer Division</td>
          <td><em>Not supported</em><br><em>Integer division is not supported for lists, but it can be applied to each list element using functions or list comprehensions. For example: <code>[x // 2 for x in [5, 9]] -> [2, 4]</code>.</em></td>
          <td><em>Not supported</em><br><em>Integer division is not supported for tuples, as they are immutable. However, you can apply integer division to each tuple element using expressions, e.g., <code>(x // 2 for x in (5, 9)) -> (2, 4)</code>.</em></td>
          <td><em>Not supported</em><br><em>Sets do not support integer division.</em></td>
          <td><em>Not supported</em><br><em>Immutable sets do not support integer division.</em></td>
          <td><em>Not supported</em><br><em>Dictionaries do not support integer division.</em></td>
          <td><em>Not supported</em><br><em>Strings do not support integer division.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([5, 9]) // np.array([2, 3]) -> array([2, 3])</code><br>
              <em>NumPy arrays support element-wise integer division.</em>
          </td>
        </tr>
      
        <tr>
          <td><code>%</code><br>Remainder (Modulo)</td>
          <td><em>Not supported</em><br><em>The remainder operation is not supported for lists, but it can be applied to each element in a list using functions or list comprehensions. For example: <code>[x % 3 for x in [5, 9]] -> [2, 0]</code>. This is useful if you need to find the remainder for each element in the list without changing the original list.</em></td>
          <td><em>Not supported</em><br><em>The remainder operation is not supported for tuples, as they are immutable. However, you can apply it to each tuple element using generators or expressions, e.g., <code>(x % 3 for x in (5, 9)) -> (2, 0)</code>. This creates a new tuple with the results of the operation.</em></td>
          <td><em>Not supported</em><br><em>Sets do not support the remainder operation, as this operation does not logically apply to unordered sets. However, you can use generators to find the remainder for each set element, for example: <code>{x % 3 for x in {5, 9}} -> {2}</code>.</em></td>
          <td><em>Not supported</em><br><em>Immutable sets do not support the remainder operation. However, you can create a new set with the results, for example: <code>{x % 3 for x in frozenset([5, 9])} -> {2}</code>.</em></td>
          <td><em>Not supported</em><br><em>Dictionaries do not support the remainder operation, as it does not fit the data structure. However, you can apply it to dictionary values with expressions, for example: <code>{k: v % 3 for k, v in {'a': 5, 'b': 9}.items()} -> {'a': 2, 'b': 0}</code>.</em></td>
          <td><em>Not supported</em><br><em>Strings do not support the remainder operation, as it has no logical meaning for text data. However, you can use functions on individual characters, e.g., <code>"abc".join([str(ord(x) % 3) for x in "abc"])</code>—this example demonstrates applying an operation on string characters.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([5, 9]) % np.array([2, 4]) -> array([1, 1])</code><br>
              <em>NumPy arrays support element-wise remainder calculations, which allow efficient calculations on each array element.</em>
          </td>
        </tr>
        <tr>
          <td><code>**</code><br>Exponentiation</td>
          <td><em>Not supported</em><br><em>Exponentiation is not supported for lists, but it can be applied to each list element using functions or list comprehensions. For example: <code>[x ** 2 for x in [2, 3]] -> [4, 9]</code>. This is useful if you want to raise each element to a power without modifying the original list.</em></td>
          <td><em>Not supported</em><br><em>Exponentiation is not supported for tuples, as they are immutable. However, you can apply it to each tuple element with expressions, for example: <code>(x ** 2 for x in (2, 3)) -> (4, 9)</code>. Using generators allows you to create a new tuple with the exponentiated values.</em></td>
          <td><em>Not supported</em><br><em>Sets do not support exponentiation, as this operation does not apply to unordered sets. However, you can use functions or expressions to raise each element to a power, e.g., <code>{x ** 2 for x in {2, 3}} -> {4, 9}</code>.</em></td>
          <td><em>Not supported</em><br><em>Immutable sets do not support exponentiation. However, similar to regular sets, you can create a new set with exponentiated values using expressions: <code>{x ** 2 for x in frozenset([2, 3])} -> {4, 9}</code>.</em></td>
          <td><em>Not supported</em><br><em>Dictionaries do not support exponentiation, as it does not apply to keys or values. However, you can apply it to dictionary values using generators or functions, e.g., <code>{k: v ** 2 for k, v in {'a': 2, 'b': 3}.items()} -> {'a': 4, 'b': 9}</code>.</em></td>
          <td><em>Not supported</em><br><em>Strings do not support exponentiation, as it does not apply to text data. However, you can use a generator or function to operate on each character, e.g., <code>"abc".join(['x' ** 2 for x in 'abc'])</code>—this example shows the concept with string characters, but exponentiation is not directly applicable to strings.</em></td>
          <td>
              <strong>NumPy</strong>: <code>np.array([2, 3]) ** 2 -> array([4, 9])</code><br>
              <em>NumPy arrays support element-wise exponentiation, allowing efficient calculations on each array element independently.</em>
          </td>
        </tr>         
        <tr>
          <td><strong>Equality Check</strong></td>
          <td><code>==<br>[1, 2] == [1, 2]<br># True</code><br><em>The `==` operator checks if the values of the objects are equal. Here, two lists contain the same elements in the same order, making them equal.</em></td>
          <td><code>==<br>(1, 2) == (1, 2)<br># True</code><br><em>Tuples are compared, and `==` checks if their elements are equal. Tuples with identical elements are considered equal, even if they are different objects in memory.</em></td>
          <td><code>==<br>{1, 2} == {2, 1}<br># True</code><br><em>Sets do not depend on the order of elements, so two sets with the same elements are equal, even if the order differs.</em></td>
          <td><code>==<br>frozenset([1, 2]) == frozenset([2, 1])<br># True</code><br><em>For `frozenset`, like sets, order does not matter, so two frozensets with the same elements are considered equal.</em></td>
          <td><code>==<br>{'a': 1} == {'a': 1}<br># True</code><br><em>Dictionaries are compared by their keys and values. If two dictionaries have identical keys and values, they are equal, regardless of their order.</em></td>
          <td><code>==<br>"abc" == "abc"<br># True</code><br><em>Strings are compared by content. Two strings with the same characters are equal, regardless of their location in memory.</em></td>
          <td><code>==<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 == arr2<br># True</code><br><em>For arrays (from the `array` module), value equality is checked, and arrays with the same elements are considered equal.</em></td>
        </tr>
        <tr>
          <td><strong>Inequality Check</strong></td>
          <td><code>!=<br>[1, 2] != [2, 1]<br># True</code><br><em>The `!=` operator checks if two objects are not equal. In this example, although both lists contain the same elements, their order differs, so the lists are not equal.</em></td>
          <td><code>!=<br>(1, 2) != (2, 1)<br># True</code><br><em>Tuples with the same elements but in different orders are considered unequal, as `!=` checks both values and order of elements.</em></td>
          <td><code>!=<br>{1, 2} != {3, 4}<br># True</code><br><em>Sets with different elements are always unequal, regardless of the element order.</em></td>
          <td><code>!=<br>frozenset([1, 2]) != frozenset([3, 4])<br># True</code><br><em>Similarly to sets, `frozenset`s with different elements are considered unequal.</em></td>
          <td><code>!=<br>{'a': 1} != {'b': 2}<br># True</code><br><em>Dictionaries with different keys or values are considered unequal, and the `!=` operator returns `True` in this case.</em></td>
          <td><code>!=<br>"abc" != "def"<br># True</code><br><em>Two strings with different content are considered unequal.</em></td>
          <td><code>!=<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [2, 1]);<br>arr1 != arr2<br># True</code><br><em>Arrays with different elements or different element orders are considered unequal.</em></td>
        </tr>
        <tr>
          <td><code>&gt;=</code><br>Greater Than or Equal To</td>
          <td><code>&gt;=<br>[3, 4] >= [3, 4]<br># True</code><br><em>The <code>&gt;=</code> operator checks if the first object is greater than or equal to the second. Lists are compared element-by-element, and if the first list is not less than the second, the result is <code>True</code>.</em></td>
          <td><code>&gt;=<br>(3, 4) >= (3, 4)<br># True</code><br><em>For tuples, the operator checks if the first tuple is greater than or equal to the second by comparing elements. If so, it returns <code>True</code>.</em></td>
          <td><code>&gt;=<br>{3, 4} >= {1, 2}<br># True</code><br><em>For sets, the <code>&gt;=</code> operator checks if the first set is a superset of the second, meaning all elements of the second set are present in the first.</em></td>
          <td><code>&gt;=<br>frozenset([3, 4]) >= frozenset([1, 2])<br># True</code><br><em>For <code>frozenset</code>, the <code>&gt;=</code> operator checks if the first set is a superset or equal to the second.</em></td>
          <td><code>&gt;=<br>{'a': 3} >= {'a': 2}<br># True</code><br><em>Dictionaries are compared by values, and the <code>&gt;=</code> operator will return <code>True</code> if the value in the first dictionary is greater than or equal to the value in the second.</em></td>
          <td><code>&gt;=<br>"abc" >= "abc"<br># True</code><br><em>Strings are compared lexicographically. The <code>&gt;=</code> operator returns <code>True</code> if the first string is equal to or follows the second alphabetically.</em></td>
          <td><code>&gt;=<br>import array;<br>arr1 = array.array('i', [3, 4]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 >= arr2<br># True</code><br><em>For arrays, each element's value is compared. The <code>&gt;=</code> operator returns <code>True</code> if the array is not less than the other.</em></td>
        </tr>      
        <tr>
          <td><code>&lt;=</code><br>Less Than or Equal To</td>
          <td><code>&lt;=<br>[1, 2] <= [3, 4]<br># True</code><br><em>The <code>&lt;=</code> operator checks if the first object is less than or equal to the second. For lists, elements are compared in order, and if the first list is less than or equal to the second by value, the result is <code>True</code>.</em></td>
          <td><code>&lt;=<br>(1, 2) <= (3, 4)<br># True</code><br><em>For tuples, the <code>&lt;=</code> operator performs an element-wise comparison. The result is <code>True</code> if all elements in the first tuple are less than or equal to the corresponding elements in the second.</em></td>
          <td><code>&lt;=<br>{1, 2} <= {3, 4}<br># True</code><br><em>Sets have no order, but the <code>&lt;=</code> operator checks if the first set is a subset of the second. If the first set contains all elements of the second or fewer, the result is <code>True</code>.</em></td>
          <td><code>&lt;=<br>frozenset([1, 2]) <= frozenset([3, 4])<br># True</code><br><em>For <code>frozenset</code>, the <code>&lt;=</code> operator checks if the first set is a subset of the second, true even for immutable sets.</em></td>
          <td><code>&lt;=<br>{'a': 1} <= {'a': 2}<br># True</code><br><em>For dictionaries, the <code>&lt;=</code> operator compares values by keys. If the values of the first dictionary are less than or equal to the values of the second, the result is <code>True</code>.</em></td>
          <td><code>&lt;=<br>"abc" <= "abc"<br># True</code><br><em>Strings are compared lexicographically. The <code>&lt;=</code> operator returns <code>True</code> if the first string is lexicographically less than or equal to the second.</em></td>
          <td><code>&lt;=<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [3, 4]);<br>arr1 <= arr2<br># True</code><br><em>For arrays, the <code>&lt=</code> operator compares elements sequentially, and if all elements in the first array are less than or equal to the corresponding elements in the second array, <code>True</code> is returned.</em></td>
        </tr>
      
                
        <tr>
          <td><strong>Identity Check</strong></td>
          <td><code>is<br>lst1 = [1, 2];<br>lst2 = lst1;<br>lst1 is lst2<br># True</code><br><em>Checks if two variables refer to the same object in memory. Useful for verifying object identity, especially when checking if variables reference the same mutable object.</em></td>
          <td><code>is<br>tup1 = (1, 2);<br>tup2 = tup1;<br>tup1 is tup2<br># True</code><br><em>Since tuples are immutable, Python may cache them, meaning identical tuples can point to the same object in memory.</em></td>
          <td><code>is<br>s1 = {1, 2};<br>s2 = s1;<br>s1 is s2<br># True</code><br><em>For sets, which are mutable, `is` checks if two variables point to the same object in memory.</em></td>
          <td><code>is<br>fs1 = frozenset([1, 2]);<br>fs2 = fs1;<br>fs1 is fs2<br># True</code><br><em>Checks identity for immutable objects like frozensets, which may be cached and thus refer to the same memory location.</em></td>
          <td><code>is<br>d1 = {'a': 1};<br>d2 = d1;<br>d1 is d2<br># True</code><br><em>Since dictionaries are mutable, using `is` verifies that both variables point to the same dictionary in memory.</em></td>
          <td><code>is<br>s1 = "abc";<br>s2 = s1;<br>s1 is s2<br># True</code><br><em>For strings, which are immutable, Python can use caching, so two variables can reference the same object if their values are identical.</em></td>
          <td><code>is<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = arr1;<br>arr1 is arr2<br># True</code><br><em>For arrays, the `is` operator checks if variables point to the same memory object, as with other mutable types.</em></td>
      </tr>
      
      <tr>
          <td><strong>Identity Check (is not)</strong></td>
          <td><code>is not<br>lst1 = [1, 2];<br>lst2 = [1, 2];<br>lst1 is not lst2<br># True</code><br><em>The `is not` operator checks that two variables do not refer to the same object in memory. In the example, <code>lst1</code> and <code>lst2</code> have the same values, but Python creates two different objects in memory, so the result is True.</em></td>
          <td><code>is not<br>tup1 = (1, 2);<br>tup2 = (1, 2);<br>tup1 is not tup2<br># True</code><br><em>Despite tuples being immutable, they may exist as distinct objects in memory even if their contents match. Hence, `is not` may return True if tuples occupy different memory locations.</em></td>
          <td><code>is not<br>s1 = {1, 2};<br>s2 = {1, 2};<br>s1 is not s2<br># True</code><br><em>For sets, as mutable objects, `is not` checks if two variables refer to different objects in memory. Identical sets by content may still be distinct objects.</em></td>
          <td><code>is not<br>fs1 = frozenset([1, 2]);<br>fs2 = frozenset([1, 2]);<br>fs1 is not fs2<br># True</code><br><em>For immutable objects like frozensets, the result can be True if they were created in separate memory locations, despite containing identical elements.</em></td>
          <td><code>is not<br>d1 = {'a': 1};<br>d2 = {'a': 1};<br>d1 is not d2<br># True</code><br><em>Dictionaries are mutable, so even if two dictionaries have the same content, they may reside in different memory locations. `is not` confirms they are separate objects.</em></td>
          <td><code>is not<br>s1 = "abc";<br>s2 = "abc";<br>s1 is not s2<br># False</code><br><em>For strings, as immutable objects, Python often caches them, so variables with identical strings may refer to the same object. In this case, `is not` often returns False.</em></td>
          <td><code>is not<br>import array;<br>arr1 = array.array('i', [1, 2]);<br>arr2 = array.array('i', [1, 2]);<br>arr1 is not arr2<br># True</code><br><em>For `array` objects, like other mutable types, `is not` checks if variables reference distinct memory objects, even if the content is the same.</em></td>
      </tr>      
      <tr>
        <td><strong>Membership Operations</strong></td>
        <td><code>in<br>lst = [1, 2, 3];<br>2 in lst<br># True</code><br><em>The <code>in</code> operator checks if an element exists in a list. In this example, it checks if the number 2 is in the list.</em></td>
        <td><code>in<br>tup = (1, 2, 3);<br>2 in tup<br># True</code><br><em>The <code>in</code> operator checks if an element exists in a tuple, similar to lists.</em></td>
        <td><code>in<br>s = {1, 2, 3};<br>2 in s<br># True</code><br><em>The <code>in</code> operator also works with sets, verifying if an element is present.</em></td>
        <td><code>in<br>fs = frozenset([1, 2, 3]);<br>2 in fs<br># True</code><br><em>The <code>in</code> operator functions with immutable sets <code>frozenset</code>, checking for element presence.</em></td>
        <td><code>in<br>d = {'a': 1, 'b': 2};<br>'a' in d<br># True</code><br><em>For dictionaries, <code>in</code> checks for the existence of a key, not the value. Here, it verifies if key <code>'a'</code> is in the dictionary.</em></td>
        <td><code>in<br>s = "abc";<br>'b' in s<br># True</code><br><em>For strings, <code>in</code> checks if a substring exists in the string. This example checks if <code>'b'</code> is in the string <code>'abc'</code>.</em></td>
        <td><code>in<br>arr = array.array('i', [1, 2, 3]);<br>2 in arr<br># True</code><br><em>For <code>array</code> objects, <code>in</code> verifies if an element is present in the array.</em></td>
      </tr>
    
      <tr>
        <td><code>not in</code><br>Checks for element absence</td>
        <td><code>not in<br>lst = [1, 2, 3];<br>4 not in lst<br># True</code><br><em>The <code>not in</code> operator checks if an element is absent in the list. Here, it verifies if 4 is not present in the list.</em></td>
        <td><code>not in<br>tup = (1, 2, 3);<br>4 not in tup<br># True</code><br><em>The <code>not in</code> operator checks if an element is absent in a tuple.</em></td>
        <td><code>not in<br>s = {1, 2, 3};<br>4 not in s<br># True</code><br><em>For sets, <code>not in</code> checks if an element is not in the set.</em></td>
        <td><code>not in<br>fs = frozenset([1, 2, 3]);<br>4 not in fs<br># True</code><br><em>For <code>frozenset</code>, <code>not in</code> verifies if an element is absent in the immutable set.</em></td>
        <td><code>not in<br>d = {'a': 1, 'b': 2};<br>'c' not in d<br># True</code><br><em>For dictionaries, <code>not in</code> checks if a key is absent.</em></td>
        <td><code>not in<br>s = "abc";<br>'d' not in s<br># True</code><br><em>For strings, <code>not in</code> checks if a substring is absent from the string.</em></td>
        <td><code>not in<br>arr = array.array('i', [1, 2, 3]);<br>4 not in arr<br># True</code><br><em>For <code>array</code> objects, <code>not in</code> checks if an element is absent from the array.</em></td>
      </tr>
    
      <tr>
        <td><strong>Iteration</strong></td>
        <td><code>for item in [1, 2, 3]:<br> print(item)</code><br><em>Iteration over a list, accessing each element in order.</em></td>
        <td><code>for item in (1, 2, 3):<br> print(item)</code><br><em>Iteration over a tuple, accessing each element in order.</em></td>
        <td><code>for item in {1, 2, 3}:<br> print(item)</code><br><em>Iteration over a set, elements are printed in an undefined order due to the nature of sets.</em></td>
        <td><code>for item in frozenset([1, 2, 3]):<br> print(item)</code><br><em>Iteration over an immutable set (frozenset), elements are printed in an undefined order.</em></td>
        <td><code>for k, v in {'a': 1}.items():<br> print(k, v)</code><br><em>Iteration over a dictionary, accessing both keys and values.</em></td>
        <td><code>for char in 'Hello':<br> print(char)</code><br><em>Iteration over a string, accessing each character in order.</em></td>
        <td><code>for item in array('i', [1, 2, 3]):<br> print(item)</code><br><em>Iteration over an array, accessing each element in order.</em></td>
       </tr>
    
  </tbody>
</table>

<a href="index.html" class="link">Go Back to Home</a>

</body>
</html>
