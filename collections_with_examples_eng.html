<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Python Collections Overview</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #f4f7fa;
    padding: 20px;
  }
  h1 {
    text-align: center;
    color: #333;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 25px 0;
    font-size: 16px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  }
  th, td {
    padding: 12px 15px;
    border: 1px solid #ddd;
    text-align: left;
  }
  th {
    background-color: #007acc;
    color: #ffffff;
    font-weight: bold;
  }
  tr:nth-child(even) {
    background-color: #f2f2f2;
  }
  tr:hover {
    background-color: #e1f5fe;
  }
  td:first-child {
    font-weight: bold;
  }
  code {
    background-color: #f9f9f9;
    padding: 5px;
    border-radius: 3px;
    word-wrap: break-word;  /* Разрешает перенос длинных слов на следующую строку */
    white-space: pre-wrap;   /* Сохраняет форматирование и позволяет тексту переноса */
    display: block;  /* Обеспечивает, чтобы каждая строка была блоком */
    margin-bottom: 8px;  /* Добавляет отступ снизу между блоками кода */
    line-height: 1.5;  /* Увеличивает межстрочное расстояние */
  }
</style>
</head>
<body>

<h1>Python Collections Overview</h1>

<table>
  <tr>
    <th>Collection Type</th>
    <th>What it is, Notes</th>
    <th>How to Define</th>
    <th>Mutability</th>
    <th>Usage Example</th>
    <th>When and Why to Use</th>
    <th>How to Access Elements</th>
  </tr>
  <tr>
    <td>List</td>
    <td>Ordered, mutable collection of items.</td>
    <td><code>[]</code> or <code>list()</code></td>
    <td>Mutable — allows modification of the existing list.</td>
    <td><code>tasks = ["task1", "task2"]<br>tasks.append("task3")</code></td>
    <td><span class="bold">When:</span> For ordered, changeable data. Task queues, student lists.<br><br><span class="bold">Why:</span> Quick insertion and access, but uses more memory for mutability.</td>
    <td><code>lst[0]</code></td>
  </tr>
  <tr>
    <td>Tuple</td>
    <td>Ordered, immutable collection.</td>
    <td><code>()</code> or <code>tuple()</code></td>
    <td>Immutable — any modification creates a new tuple.</td>
    <td><code>coordinates = (10, 20)</code></td>
    <td><span class="bold">When:</span> For immutable data, such as coordinates or dictionary keys.<br><br><span class="bold">Why:</span> More efficient memory usage; safe if no changes are needed.</td>
    <td><code>tpl[0]</code></td>
  </tr>
  <tr>
    <td>Set</td>
    <td>Unordered collection of unique elements.</td>
    <td><code>{}</code> or <code>set()</code></td>
    <td>Mutable — elements can be added or removed without creating a new set.</td>
    <td><code>tags = {"python", "coding"}<br>tags.add("tutorial")</code></td>
    <td><span class="bold">When:</span> For unique elements. Tags, user IDs.<br><br><span class="bold">Why:</span> Efficient removal of duplicates and searching; uses less memory than lists.</td>
    <td>No indexing</td>
  </tr>
  <tr>
    <td>Frozen Set</td>
    <td>Similar to a set, but immutable.</td>
    <td><code>frozenset()</code></td>
    <td>Immutable — any modification creates a new <code>frozenset</code> object.</td>
    <td><code>frozen_tags = frozenset(["python", "tutorial"])</code></td>
    <td><span class="bold">When:</span> For fixed, unique elements. Constants, fixed tags.<br><br><span class="bold">Why:</span> Useful for immutable sets of unique data; less overhead.</td>
    <td>No indexing</td>
  </tr>
  <tr>
    <td>Dictionary</td>
    <td>Collection of key-value pairs.</td>
    <td><code>{}</code> or <code>dict()</code></td>
    <td>Mutable — key-value pairs can be added or modified without creating a new dictionary.</td>
    <td><code>user = {"name": "John", "age": 30}</code></td>
    <td><span class="bold">When:</span> For storing key-value data. User settings, word frequencies.<br><br><span class="bold">Why:</span> Fast key-based access, but uses more memory for indexing.</td>
    <td><code>dct['key']</code></td>
  </tr>
  <tr>
    <td>Array</td>
    <td>Optimized for numerical data, saves memory.</td>
    <td><code>array.array()</code></td>
    <td>Mutable — existing arrays can be modified.</td>
    <td><code>import array<br>arr = array.array('i', [1, 2, 3])</code></td>
    <td><span class="bold">When:</span> For homogeneous data. Example: handling large numeric datasets.<br><br><span class="bold">Why:</span> Uses less memory than lists but only for homogeneous data types.</td>
    <td><code>arr[0]</code></td>
  </tr>
  <tr>
    <td>String</td>
    <td>A sequence of characters, supports indexing and slicing.</td>
    <td><code>""</code> or <code>str()</code></td>
    <td>Immutable — any change creates a new string.</td>
    <td><code>name = "Alice"<br>name.upper()</code></td>
    <td><span class="bold">When:</span> For working with text. Names, passwords, messages.<br><br><span class="bold">Why:</span> Uses less memory, safe for immutable texts.</td>
    <td><code>s[0]</code></td>
  </tr>
</table>

</body>
</html>
